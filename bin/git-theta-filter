#!/usr/bin/env python

import argparse
import os
import sys
import subprocess
import re
import json
import git
import logging
import hashlib
from collections import defaultdict, OrderedDict
import tempfile
import pdb

from git_theta import git_utils, checkpoints, params, file_io, utils, theta

logging.basicConfig(
    level=logging.DEBUG,
    format="git-theta-filter: [%(asctime)s] %(levelname)s - %(message)s",
)


def parse_args():
    parser = argparse.ArgumentParser(description="git-theta filter program")
    subparsers = parser.add_subparsers(title="Commands", dest="command")
    subparsers.required = True

    clean_parser = subparsers.add_parser("clean", help="clean filter")
    clean_parser.add_argument("file", help="file being passed to clean filter")
    clean_parser.set_defaults(func=clean)

    smudge_parser = subparsers.add_parser("smudge", help="smudge filter")
    smudge_parser.add_argument("file", help="file being passed to smudge filter")
    smudge_parser.set_defaults(func=smudge)

    args = parser.parse_args()
    return args


def clean(args):
    """
    Implements clean filter for model files
    Metadata file looks as follows:
    {
    "model/scoping/to/param/1-weight": {
        "tensor_metadata": {
            "shape": List[str],
            "dtype": str,
            "hash": str,
        },
    },
    ...,
    "model/scoping/to/param/2-bias": {
        "tensor_metadata": {
            "shape": List[str],
            "dtype": str,
            "hash": str,
        },
    },
    ...,
    }
    """
    logging.debug(f"Running clean filter on {args.file}")
    repo = git_utils.get_git_repo()
    theta_dir = theta.ThetaDirectory(repo)

    checkpoint_handler = checkpoints.get_checkpoint_handler()
    model_checkpoint = checkpoint_handler.from_file(sys.stdin.buffer)

    # TODO(bdlester): If we use Python3.7 as the minimum version, we don't need
    # to use an OrderedDict as the standard dict retains the insertion order.
    staged_file_contents = OrderedDict()
    # Sort the keys so we don't get changing diffs based on serialization order.
    for keys, param in sorted(utils.flatten(model_checkpoint).items()):
        param_name = ".".join(keys)
        param_metadata = OrderedDict()
        with tempfile.TemporaryDirectory(dir=theta_dir.tmp) as tmpdir:
            param_dir = os.path.join(tmpdir, param_name)
            file_io.write_tracked_file(param_dir, param)
            for param_file in sorted(os.listdir(param_dir)):
                lfs_metadata = git_utils.git_lfs_clean(os.path.join(param_dir, param_file))
                param_metadata[param_file] = lfs_metadata

        staged_file_contents[keys] = param_metadata
    file_io.write_staged_file(sys.stdout, utils.unflatten(staged_file_contents))


def smudge(args):
    """
    Implements smudge filter for model files
    """
    logging.debug(f"Running smudge filter on {args.file}")

    repo = git_utils.get_git_repo()
    theta_dir = theta.ThetaDirectory(repo)

    staged_file = utils.flatten(file_io.load_staged_file(sys.stdin), is_leaf=lambda l: any(('oid' in v for v in l.values())))
    model_dict = {}
    for keys, param_metadata in staged_file.items():
        with tempfile.TemporaryDirectory(dir=theta_dir.tmp) as param_directory:
            for file, lfs_metadata in param_metadata.items():
                with tempfile.NamedTemporaryFile(mode='rb+', dir=theta_dir.tmp) as lfs_pointer_file:
                    lfs_pointer_file.write(f'version {lfs_metadata["lfs_version"]}\noid sha256:{lfs_metadata["oid"]}\nsize {lfs_metadata["size"]}'.encode())
                    lfs_pointer_file.seek(0)
                    param_file_contents = git_utils.git_lfs_smudge(lfs_pointer_file)
                with open(os.path.join(param_directory, file), 'wb') as param_file:
                    param_file.write(param_file_contents)

            param = file_io.load_tracked_file(param_directory)
            model_dict[keys] = param

    checkpoint_handler = checkpoints.get_checkpoint_handler()
    model_checkpoint = checkpoint_handler(utils.unflatten(model_dict))
    model_checkpoint.save(sys.stdout.buffer)


if __name__ == "__main__":
    args = parse_args()
    git_utils.set_hooks()
    args.func(args)
