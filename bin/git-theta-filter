#!/usr/bin/env python

import argparse
import os
import sys
import subprocess
import re
import json
import git
import logging
import hashlib
from collections import defaultdict, OrderedDict
import tempfile
import pdb

from git_theta import git_utils, checkpoints, params, file_io, utils, theta

logging.basicConfig(
    level=logging.DEBUG,
    format="git-theta-filter: [%(asctime)s] [%(funcName)s] %(levelname)s - %(message)s",
)


def parse_args():
    parser = argparse.ArgumentParser(description="git-theta filter program")
    subparsers = parser.add_subparsers(title="Commands", dest="command")
    subparsers.required = True

    clean_parser = subparsers.add_parser("clean", help="clean filter")
    clean_parser.add_argument("file", help="file being passed to clean filter")
    clean_parser.set_defaults(func=clean)

    smudge_parser = subparsers.add_parser("smudge", help="smudge filter")
    smudge_parser.add_argument("file", help="file being passed to smudge filter")
    smudge_parser.set_defaults(func=smudge)

    args = parser.parse_args()
    return args


def clean(args):
    """
    Implements clean filter for model files
    Metadata file looks as follows:
    {
    "model/scoping/to/param/1-weight": {
        "tensor_metadata": {
            "shape": List[str],
            "dtype": str,
            "hash": str,
        },
    },
    ...,
    "model/scoping/to/param/2-bias": {
        "tensor_metadata": {
            "shape": List[str],
            "dtype": str,
            "hash": str,
        },
    },
    ...,
    }
    """
    logging.debug(f"Running clean filter on {args.file}")
    repo = git_utils.get_git_repo()

    checkpoint_handler = checkpoints.get_checkpoint_handler()
    model_checkpoint = checkpoint_handler.from_file(sys.stdin.buffer)

    # TODO(bdlester): If we use Python3.7 as the minimum version, we don't need
    # to use an OrderedDict as the standard dict retains the insertion order.
    staged_file_contents = OrderedDict()
    # Sort the keys so we don't get changing diffs based on serialization order.
    for keys, param in sorted(utils.flatten(model_checkpoint).items()):
        param_name = "/".join(keys)
        logging.debug(f"Cleaning {param_name}")
        file_contents = file_io.write_tracked_file_to_memory(param)
        lfs_metadata = git_utils.git_lfs_clean(file_contents)
        staged_file_contents[keys] = lfs_metadata
    file_io.write_staged_file(sys.stdout, utils.unflatten(staged_file_contents))


def smudge(args):
    """
    Implements smudge filter for model files
    """
    logging.debug(f"Running smudge filter on {args.file}")

    repo = git_utils.get_git_repo()
    staged_file = utils.flatten(file_io.load_staged_file(sys.stdin), is_leaf=lambda l: 'oid' in l)
    model_dict = {}
    for param_keys, param_metadata in staged_file.items():
        logging.debug(f"Smudging {'/'.join(param_keys)}")
        lfs_pointer = f'version {param_metadata["lfs_version"]}\noid sha256:{param_metadata["oid"]}\nsize {param_metadata["size"]}'.encode()
        param_contents = git_utils.git_lfs_smudge(lfs_pointer)
        param = file_io.load_tracked_file_from_memory(param_contents)
        model_dict[param_keys] = param
    checkpoint_handler = checkpoints.get_checkpoint_handler()
    model_checkpoint = checkpoint_handler(utils.unflatten(model_dict))
    model_checkpoint.save(sys.stdout.buffer)


if __name__ == "__main__":
    args = parse_args()
    git_utils.set_hooks()
    args.func(args)
