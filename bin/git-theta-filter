#!/usr/bin/env python

import argparse
import sys
import logging

from git_theta import git_utils, checkpoints, params, metadata, updates

logging.basicConfig(
    level=logging.DEBUG,
    format="git-theta-filter: [%(asctime)s] [%(funcName)s] %(levelname)s - %(message)s",
)


def parse_args():
    parser = argparse.ArgumentParser(description="git-theta filter program")
    subparsers = parser.add_subparsers(title="Commands", dest="command")
    subparsers.required = True

    clean_parser = subparsers.add_parser("clean", help="clean filter")
    clean_parser.add_argument("file", help="file being passed to clean filter")
    clean_parser.set_defaults(func=clean)

    smudge_parser = subparsers.add_parser("smudge", help="smudge filter")
    smudge_parser.add_argument("file", help="file being passed to smudge filter")
    smudge_parser.set_defaults(func=smudge)

    args = parser.parse_args()
    return args


def clean(args):
    """
    Implements clean filter for model files
    Metadata file looks as follows:
    {
    "model/scoping/to/param/1-weight": {
        "tensor_metadata": {
            "shape": List[str],
            "dtype": str,
            "hash": str,
        },
    },
    ...,
    "model/scoping/to/param/2-bias": {
        "tensor_metadata": {
            "shape": List[str],
            "dtype": str,
            "hash": str,
        },
    },
    ...,
    }
    """
    logging.debug(f"Running clean filter on {args.file}")
    repo = git_utils.get_git_repo()

    checkpoint_handler = checkpoints.get_checkpoint_handler()
    model_checkpoint = checkpoint_handler.from_file(sys.stdin.buffer)

    prev_metadata = metadata.Metadata.from_commit(repo, args.file, "HEAD").flatten()
    new_metadata = metadata.Metadata()
    # Sort the keys so we don't get changing diffs based on serialization order.
    for param_keys, new_param in sorted(model_checkpoint.flatten().items()):
        logging.debug(f"Cleaning {'/'.join(param_keys)}")

        param_metadata = prev_metadata.get(param_keys)
        new_tensor_metadata = metadata.TensorMetadata.from_tensor(new_param)
        # If the parameter tensor has not changed, just keep the metadata the same
        #TODO: currently checks if rounded parameter hash has changed. Look into better parameter equality checks.
        if param_metadata and param_metadata.tensor_metadata == new_tensor_metadata:
            new_param_metadata = param_metadata
        # If it's changed, update this parameter's metadata
        else:
            update = updates.get_update()()
            update_serializer = params.get_update_serializer()

            new_theta_metadata = metadata.ThetaMetadata(update_type=update.name, last_commit=git_utils.get_head(repo))
            param_update = update.calculate_update(repo, args.file, param_keys, param_metadata, new_param)
            serialized_update = update_serializer.serialize(param_update)
            new_lfs_metadata = metadata.LfsMetadata.from_bytes(serialized_update)
            new_param_metadata = metadata.ParamMetadata(lfs_metadata=new_lfs_metadata,
                                                      tensor_metadata=new_tensor_metadata,
                                                      theta_metadata=new_theta_metadata)

        new_metadata[param_keys] = new_param_metadata
    new_metadata.unflatten().write(sys.stdout)


def smudge(args):
    """
    Implements smudge filter for model files
    """
    logging.debug(f"Running smudge filter on {args.file}")

    repo = git_utils.get_git_repo()
    curr_metadata = metadata.Metadata.from_file(sys.stdin).flatten()

    model_dict = {}
    for param_keys, param_metadata in curr_metadata.items():
        logging.debug(f"Smudging {'/'.join(param_keys)}")
        update = updates.get_update(param_metadata.theta_metadata.update_type)()
        model_dict[param_keys] = update.apply(repo, args.file, param_keys, param_metadata)

    checkpoint_handler = checkpoints.get_checkpoint_handler()
    model_checkpoint = checkpoint_handler(model_dict).unflatten()
    model_checkpoint.save(sys.stdout.buffer)


if __name__ == "__main__":
    args = parse_args()
    git_utils.set_hooks()
    args.func(args)
