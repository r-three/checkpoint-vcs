#!/usr/bin/env python

import argparse
import os
import sys
import subprocess
import re
import json
import git
import logging
import hashlib
from collections import defaultdict, OrderedDict
import tempfile
import pdb

from git_theta import git_utils, checkpoints, params, file_io, utils, theta, updates

logging.basicConfig(
    level=logging.DEBUG,
    format="git-theta-filter: [%(asctime)s] [%(funcName)s] %(levelname)s - %(message)s",
)


def parse_args():
    parser = argparse.ArgumentParser(description="git-theta filter program")
    subparsers = parser.add_subparsers(title="Commands", dest="command")
    subparsers.required = True

    clean_parser = subparsers.add_parser("clean", help="clean filter")
    clean_parser.add_argument("file", help="file being passed to clean filter")
    clean_parser.set_defaults(func=clean)

    smudge_parser = subparsers.add_parser("smudge", help="smudge filter")
    smudge_parser.add_argument("file", help="file being passed to smudge filter")
    smudge_parser.set_defaults(func=smudge)

    args = parser.parse_args()
    return args


def clean(args):
    """
    Implements clean filter for model files
    Metadata file looks as follows:
    {
    "model/scoping/to/param/1-weight": {
        "tensor_metadata": {
            "shape": List[str],
            "dtype": str,
            "hash": str,
        },
    },
    ...,
    "model/scoping/to/param/2-bias": {
        "tensor_metadata": {
            "shape": List[str],
            "dtype": str,
            "hash": str,
        },
    },
    ...,
    }
    """
    logging.debug(f"Running clean filter on {args.file}")
    repo = git_utils.get_git_repo()

    checkpoint_handler = checkpoints.get_checkpoint_handler()
    model_checkpoint = checkpoint_handler.from_file(sys.stdin.buffer)

    obj = git_utils.get_file_version(repo, args.file, "HEAD")
    if obj:
        metadata = file_io.load_metadata_file(obj.data_stream).flatten()
    else:
        metadata = params.Metadata()

    new_metadata = params.Metadata()
    # Sort the keys so we don't get changing diffs based on serialization order.
    for param_keys, new_param in sorted(model_checkpoint.flatten().items()):
        logging.debug(f"Cleaning {'/'.join(param_keys)}")

        param_metadata = metadata.get(param_keys)
        new_tensor_metadata = params.TensorMetadata.from_tensor(new_param)
        # If the parameter tensor has not changed, just keep the metadata the same
        #TODO: check if parameter has changed based on something fuzzier than tensor hash
        if param_metadata and param_metadata.tensor_metadata == new_tensor_metadata:
            new_param_metadata = param_metadata
        # If it's changed, update this parameter's metadata
        else:
            update = updates.get_update()()
            new_theta_metadata = params.ThetaMetadata(update_type=update.name, last_commit=git_utils.get_head(repo))

            param_update = update.calculate_update(repo, args.file, param_keys, param_metadata, new_param)
            update_contents = file_io.write_tracked_file_to_memory(param_update)
            new_lfs_metadata = params.LfsMetadata.from_bytes(update_contents)
            new_param_metadata = params.ParamMetadata(lfs_metadata=new_lfs_metadata,
                                                      tensor_metadata=new_tensor_metadata,
                                                      theta_metadata=new_theta_metadata)

        new_metadata[param_keys] = new_param_metadata
    file_io.write_metadata_file(sys.stdout, new_metadata.unflatten())


def smudge(args):
    """
    Implements smudge filter for model files
    """
    logging.debug(f"Running smudge filter on {args.file}")

    repo = git_utils.get_git_repo()
    metadata = file_io.load_metadata_file(sys.stdin).flatten()

    model_dict = {}
    for param_keys, param_metadata in metadata.items():
        logging.debug(f"Smudging {'/'.join(param_keys)}")
        update = updates.get_update(param_metadata.theta_metadata.update_type)()
        model_dict[param_keys] = update.apply(repo, args.file, param_keys, param_metadata)

    checkpoint_handler = checkpoints.get_checkpoint_handler()
    model_checkpoint = checkpoint_handler(model_dict).unflatten()
    model_checkpoint.save(sys.stdout.buffer)


if __name__ == "__main__":
    args = parse_args()
    git_utils.set_hooks()
    args.func(args)
