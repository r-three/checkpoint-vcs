#!/usr/bin/env python

import argparse
import os
import sys
import re
import git
import logging

from git_cml import git_utils, checkpoints, file_io

logging.basicConfig(
    level=logging.DEBUG, format="git-cml: [%(asctime)s] %(levelname)s - %(message)s"
)


def parse_args():
    parser = argparse.ArgumentParser("git-cml filter program")
    subparsers = parser.add_subparsers(title="Commands", dest="command")
    subparsers.required = True

    add_parser = subparsers.add_parser(
        "add", help="add command used to stage a model file"
    )
    add_parser.add_argument("file", help="file being staged")
    add_parser.set_defaults(func=add)

    install_parser = subparsers.add_parser(
        "install", help="install command used to setup global .gitconfig"
    )
    install_parser.set_defaults(func=install)

    track_parser = subparsers.add_parser(
        "track",
        help="track command used to identify model checkpoint for git-cml to track",
    )
    track_parser.add_argument(
        "file", help="model checkpoint file or file pattern to track"
    )
    track_parser.set_defaults(func=track)

    args = parser.parse_args()
    return args


def iterate_dict_and_dir_leaves(d, root):
    """
    Generator that iterates through dictionary leaves and produces (param, param_file) tuples where param is a dictionary leaf
    and param_file is the file below root corresponding to the sequence of keys used to access the dictionary leaf. Each subdirectory
    between root and param_file is created if it does not exist.

    Example
    -------
    d = {'a': {'b': {'c': 10, 'd': 20, 'e': 30}}}
    root = 'rootdir'
    iterate_dict_and_dir_leaves(d, root) --> ((10, 'rootdir/a/b/c'), (20, 'rootdir/a/b/d'), (30, 'rootdir/a/b/e'))

    Parameters
    ----------
    d : dict
        dictionary to iterate over
    root : str
        path to root directory where directory tree representing `d` is created
    """
    for leaf, keys in checkpoints.iterate_dict_leaves(d):
        param_dir = os.path.join(root, "/".join(keys))
        if not os.path.exists(param_dir):
            os.makedirs(param_dir)
        yield leaf, param_dir


def iterate_removed_params(d, root):
    """
    Generator that iterates a model directory and yields the parameter groups that are present in the model directory but not in the model dictionary

    Example
    -------

    Parameters
    ----------
    """
    for leaf, keys in checkpoints.iterate_dir_leaves(root):
        curr_d = d
        for k in keys:
            if curr_d.get(k) is None:
                yield leaf
                continue
            curr_d = curr_d[k]


def add(args):
    """
    Splits model parameters file into parameter groups on filesystem and stages files
    """
    repo = git_utils.get_git_repo()
    model_path = git_utils.get_relative_path_from_root(repo, args.file)
    cml_model_dir = git_utils.get_git_cml_model_dir(repo, model_path, create=True)

    param_dict = checkpoints.PyTorchCheckpoint.from_file(args.file)
    for (param, param_dir) in iterate_dict_and_dir_leaves(param_dict, cml_model_dir):
        param_file = os.path.join(param_dir, "params")
        file_io.write_tracked_file(param_file, param)
        git_utils.add_file(param_file, repo)
    
    for param_file in iterate_removed_params(param_dict, cml_model_dir):
        git_utils.remove_file(param_file, repo)

    git_utils.add_file(model_path, repo)


def install(args):
    """
    Install git-lfs and initialize the git-cml filter driver
    """
    git_utils.git_lfs_install()
    config_writer = git.GitConfigParser(
        git.config.get_config_path("global"), config_level="global", read_only=False
    )
    config_writer.remove_option('filter "lfs"', "process")
    config_writer.set_value('filter "cml"', "clean", "git-cml-filter clean %f")
    config_writer.set_value('filter "cml"', "smudge", "git-cml-filter smudge %f")
    config_writer.set_value('filter "cml"', "required", "true")
    config_writer.release()


def track(args):
    """
    Track a particular model checkpoint file with git-cml
    """
    repo = git_utils.get_git_repo()
    model_path = git_utils.get_relative_path_from_root(repo, args.file)

    # Initialize git lfs to track model files in .git_cml
    cml_model_dir = git_utils.get_git_cml_model_dir(repo, model_path)
    git_utils.git_lfs_track(repo, cml_model_dir)

    gitattributes_file = git_utils.get_gitattributes_file(repo)
    gitattributes = git_utils.read_gitattributes(gitattributes_file)

    pattern_found = False
    for line in gitattributes:
        match = re.match("^\s*(?P<pattern>[^\s]+)\s+(?P<attributes>.*)$", line)
        if match is None:
            continue
        if match.group("pattern") != args.file:
            continue
        if not "filter=cml" in match.group("attributes"):
            line += " filter=cml"
        pattern_found = True

    if not pattern_found:
        gitattributes.append(f"{model_path} filter=cml")

    git_utils.write_gitattributes(gitattributes_file, gitattributes)
    git_utils.add_file(gitattributes_file, repo)


if __name__ == "__main__":
    args = parse_args()
    args.func(args)
