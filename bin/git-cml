#!/usr/bin/env python

import argparse
import os
import sys
import subprocess
import re
import json
import git
import logging

from git_cml import git_utils, checkpoints

logging.basicConfig(
    level=logging.DEBUG, format="git-cml: [%(asctime)s] %(levelname)s - %(message)s"
)


def parse_args():
    parser = argparse.ArgumentParser("git-cml filter program")
    subparsers = parser.add_subparsers(title="Commands", dest="command")
    subparsers.required = True

    add_parser = subparsers.add_parser(
        "add", help="add command used to stage a model file"
    )
    add_parser.add_argument("file", help="file being staged")
    add_parser.set_defaults(func=add)

    init_parser = subparsers.add_parser(
        "init", help="init command used to setup a git-cml repo"
    )
    init_parser.set_defaults(func=init)

    args = parser.parse_args()
    return args


def iterate_dict_and_dir_leaves(d, root):
    """
    Generator that iterates through dictionary leaves and produces (param, param_file) tuples where param is a dictionary leaf
    and param_file is the file below root corresponding to the sequence of keys used to access the dictionary leaf. Each subdirectory
    between root and param_file is created if it does not exist.

    Example
    -------
    d = {'a': {'b': {'c': 10, 'd': 20, 'e': 30}}}
    root = 'rootdir'
    iterate_dict_and_dir_leaves(d, root) --> ((10, 'rootdir/a/b/c'), (20, 'rootdir/a/b/d'), (30, 'rootdir/a/b/e'))

    Parameters
    ----------
    d : dict
        dictionary to iterate over
    root : str
        path to root directory where directory tree representing `d` is created
    """
    for leaf, keys in checkpoints.iterate_dict_leaves(d):
        param_file = os.path.join(root, "/".join(keys))
        if not os.path.exists(os.path.dirname(param_file)):
            os.makedirs(os.path.dirname(param_file))
        yield leaf, param_file


def add(args):
    """
    Splits model parameters file into parameter groups on filesystem and stages files
    """
    repo = git_utils.get_git_repo()
    model_path = git_utils.create_git_cml_model_dir(repo, args.file)

    param_dict = checkpoints.PyTorchCheckpoint.from_file(args.file)
    for (param, param_file) in iterate_dict_and_dir_leaves(param_dict, model_path):
        git_utils.write_tracked_file(param_file, param)
        git_utils.add_file(param_file, repo)

    git_utils.add_file(args.file, repo)


def init(args):
    """
    Set up git-cml repo by initializing .git/info/attributes and .git/config
    """
    repo = git_utils.get_git_repo()
    config_writer = repo.config_writer()
    config_writer.set_value('filter "cml"', "clean", "git-cml-filter clean %f")
    config_writer.set_value('filter "cml"', "smudge", "git-cml-filter smudge %f")
    config_writer.set_value('filter "cml"', "required", "true")
    config_writer.release()

    with open(os.path.join(repo.working_dir, ".git/info/attributes"), "w+") as f:
        f.write("*.pt filter=cml")



if __name__ == "__main__":
    args = parse_args()
    args.func(args)
